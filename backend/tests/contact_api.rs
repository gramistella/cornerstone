// backend/tests/contacts_api.rs
use common::ContactDto;
use reqwest::StatusCode;
mod helpers;
use once_cell::sync::Lazy;

static TRACING: Lazy<()> = Lazy::new(|| {
    let subscriber = tracing_subscriber::fmt().with_max_level(tracing::Level::DEBUG);
    subscriber.init();
});

#[tokio::test]
async fn test_contacts_crud_flow() {

    Lazy::force(&TRACING);

    // Arrange: Spawn the app and get an authenticated client
    let (addr, client, _db_pool) = helpers::spawn_app().await;
    let token = helpers::get_auth_token(&addr, &client).await;

    let contacts_url = format!("http://{}/api/v1/contacts", addr);

    // 1. Initially, GET contacts should return an empty list
    let response = client
        .get(&contacts_url)
        .bearer_auth(&token)
        .send()
        .await
        .expect("Failed to execute request.");
    
    assert_eq!(response.status(), StatusCode::OK);
    let contacts: Vec<ContactDto> = response.json().await.unwrap();
    assert!(contacts.is_empty(), "Initially there should be no contacts.");

    // 2. CREATE a new contact
    let new_contact = ContactDto {
        id: None, // ID is generated by the DB
        name: "John Doe".to_string(),
        email: "john.doe@test.com".to_string(),
        age: 30,
        subscribed: true,
        contact_type: "Friend".to_string(),
    };

    let response = client
        .post(&contacts_url)
        .bearer_auth(&token)
        .json(&new_contact)
        .send()
        .await
        .expect("Failed to execute request.");

    assert_eq!(response.status(), StatusCode::CREATED);
    let created_contact: ContactDto = response.json().await.unwrap();
    assert_eq!(created_contact.name, new_contact.name);
    assert!(created_contact.id.is_some());

    let contact_id = created_contact.id.unwrap();
    let single_contact_url = format!("{}/{}", contacts_url, contact_id);

    // 3. GET the created contact by its ID
    let response = client
        .get(&single_contact_url)
        .bearer_auth(&token)
        .send()
        .await
        .expect("Failed to execute request.");

    assert_eq!(response.status(), StatusCode::OK);
    let fetched_contact: ContactDto = response.json().await.unwrap();
    assert_eq!(fetched_contact.id, Some(contact_id));
    assert_eq!(fetched_contact.name, "John Doe");

    // 4. UPDATE the contact
    let updated_contact_data = ContactDto {
        id: Some(contact_id),
        name: "John Smith".to_string(), // Name changed
        email: "john.smith@test.com".to_string(), // Email changed
        age: 31,
        subscribed: false,
        contact_type: "Work".to_string(),
    };

    let response = client
        .put(&single_contact_url)
        .bearer_auth(&token)
        .json(&updated_contact_data)
        .send()
        .await
        .expect("Failed to execute request.");

    assert_eq!(response.status(), StatusCode::OK);
    let updated_contact_response: ContactDto = response.json().await.unwrap();
    assert_eq!(updated_contact_response.name, "John Smith");
    assert_eq!(updated_contact_response.age, 31);


    // 5. DELETE the contact
    let response = client
        .delete(&single_contact_url)
        .bearer_auth(&token)
        .send()
        .await
        .expect("Failed to execute request.");

    assert_eq!(response.status(), StatusCode::NO_CONTENT);

    // 6. Verify the contact is gone
    let response = client
        .get(&single_contact_url)
        .bearer_auth(&token)
        .send()
        .await
        .expect("Failed to execute request.");
    
    assert_eq!(response.status(), StatusCode::NOT_FOUND);
}